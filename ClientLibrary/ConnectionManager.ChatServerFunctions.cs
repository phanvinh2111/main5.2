// <copyright file="ConnectionManager.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (publish/rebuild the
//     client library project).
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable RedundantVerbatimPrefix
// ReSharper disable AssignmentIsFullyDiscarded
// ReSharper disable UnusedMember.Global
// ReSharper disable UseObjectOrCollectionInitializer

#nullable enable
namespace MUnique.Client.Library;

using System;
using System.Runtime.InteropServices;
using System.Text;

using MUnique.OpenMU.Network;
using MUnique.OpenMU.Network.Packets;
using MUnique.OpenMU.Network.Packets.ChatServer;

/// <summary>
/// Extension methods to start writing messages of this namespace on a <see cref="IConnection"/>.
/// </summary>
public unsafe partial class ConnectionManager
{

    /// <summary>
    /// Sends a <see cref="Authenticate" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <param name="roomId">The room id.</param>
    /// <param name="token">A token (integer number), formatted as string and "encrypted" with the 3-byte XOR key (FC CF AB).</param>
    /// <param name="tokenByteLength">The length of <paramref name="token"/>.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client after it connected to the server, to authenticate itself.
    /// Causes reaction on server side: The server will check the token. If it's correct, the client gets added to the requested chat room.
    /// </remarks>
    [UnmanagedCallersOnly(EntryPoint = "SendAuthenticate")]
    public static void SendAuthenticate(int handle, ushort @roomId, byte* @token, uint tokenByteLength)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            connection.CreateAndSend(pipeWriter =>
            {
                var length = AuthenticateRef.Length;
                var packet = new AuthenticateRef(pipeWriter.GetSpan(length)[..length]);
                packet.RoomId = @roomId;
                new Span<byte>(@token, (int)tokenByteLength).CopyTo(packet.Token);

                return length;
            });
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="ChatRoomClientJoined" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <param name="clientIndex">The client index.</param>
    /// <param name="name">The name.</param>
    /// <remarks>
    /// Is sent by the server when: This packet is sent by the server after another chat client joined the chat room.
    /// Causes reaction on client side: The client will add the client in its list (if over 2 clients are connected to the same room), or show its name in the title bar.
    /// </remarks>
    [UnmanagedCallersOnly(EntryPoint = "SendChatRoomClientJoined")]
    public static void SendChatRoomClientJoined(int handle, byte @clientIndex, IntPtr @name)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            connection.CreateAndSend(pipeWriter =>
            {
                var length = ChatRoomClientJoinedRef.Length;
                var packet = new ChatRoomClientJoinedRef(pipeWriter.GetSpan(length)[..length]);
                packet.ClientIndex = @clientIndex;
                packet.Name = Marshal.PtrToStringAuto(@name);

                return length;
            });
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="LeaveChatRoom" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client when it leaves the chat room, before the connection closes.
    /// Causes reaction on server side: The server will remove the client from the chat room, notifying the remaining clients.
    /// </remarks>
    [UnmanagedCallersOnly(EntryPoint = "SendLeaveChatRoom")]
    public static void SendLeaveChatRoom(int handle)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            connection.CreateAndSend(pipeWriter =>
            {
                var length = LeaveChatRoomRef.Length;
                var packet = new LeaveChatRoomRef(pipeWriter.GetSpan(length)[..length]);
                return length;
            });
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="ChatRoomClientLeft" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <param name="clientIndex">The client index.</param>
    /// <param name="name">The name.</param>
    /// <remarks>
    /// Is sent by the server when: This packet is sent by the server after a chat client left the chat room.
    /// Causes reaction on client side: The client will remove the client from its list, or mark its name in the title bar as offline.
    /// </remarks>
    [UnmanagedCallersOnly(EntryPoint = "SendChatRoomClientLeft")]
    public static void SendChatRoomClientLeft(int handle, byte @clientIndex, IntPtr @name)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            connection.CreateAndSend(pipeWriter =>
            {
                var length = ChatRoomClientLeftRef.Length;
                var packet = new ChatRoomClientLeftRef(pipeWriter.GetSpan(length)[..length]);
                packet.ClientIndex = @clientIndex;
                packet.Name = Marshal.PtrToStringAuto(@name);

                return length;
            });
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="ChatMessage" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <param name="senderIndex">The sender index.</param>
    /// <param name="messageLength">The message length.</param>
    /// <param name="message">The message. It's "encrypted" with the 3-byte XOR key (FC CF AB).</param>
    /// <param name="messageByteLength">The length of <paramref name="message"/>.</param>
    /// <remarks>
    /// Is sent by the server when: This packet is sent by the server after another chat client sent a message to the current chat room.
    /// Causes reaction on client side: The client will show the message.
    /// </remarks>
    [UnmanagedCallersOnly(EntryPoint = "SendChatMessage")]
    public static void SendChatMessage(int handle, byte @senderIndex, byte @messageLength, byte* @message, uint messageByteLength)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            connection.CreateAndSend(pipeWriter =>
            {
                var length = ChatMessageRef.GetRequiredSize((int)messageByteLength);
                var packet = new ChatMessageRef(pipeWriter.GetSpan(length)[..length]);
                packet.SenderIndex = @senderIndex;
                packet.MessageLength = @messageLength;
                new Span<byte>(@message, (int)messageByteLength).CopyTo(packet.Message);

                return length;
            });
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="KeepAlive" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client in a fixed interval.
    /// Causes reaction on server side: The server will keep the connection and chat room intact as long as the clients sends a message in a certain period of time.
    /// </remarks>
    [UnmanagedCallersOnly(EntryPoint = "SendKeepAlive")]
    public static void SendKeepAlive(int handle)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            connection.CreateAndSend(pipeWriter =>
            {
                var length = KeepAliveRef.Length;
                var packet = new KeepAliveRef(pipeWriter.GetSpan(length)[..length]);
                return length;
            });
        }
        catch
        {
            // Log exception
        }
    }}