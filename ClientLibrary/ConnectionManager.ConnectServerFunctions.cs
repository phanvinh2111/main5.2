// <copyright file="ConnectionManager.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (publish/rebuild the
//     client library project).
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable RedundantVerbatimPrefix
// ReSharper disable AssignmentIsFullyDiscarded
// ReSharper disable UnusedMember.Global
// ReSharper disable UseObjectOrCollectionInitializer

#nullable enable
namespace MUnique.Client.Library;

using System;
using System.Runtime.InteropServices;
using System.Text;

using MUnique.OpenMU.Network;
using MUnique.OpenMU.Network.Packets;
using MUnique.OpenMU.Network.Packets.ConnectServer;

/// <summary>
/// Extension methods to start writing messages of this namespace on a <see cref="IConnection"/>.
/// </summary>
public unsafe partial class ConnectionManager
{

    /// <summary>
    /// Sends a <see cref="ConnectionInfoRequest075" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <param name="serverId">The server id.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client after the user clicked on an entry of the server list.
    /// Causes reaction on server side: The server will send a ConnectionInfo back to the client.
    /// </remarks>
    [UnmanagedCallersOnly(EntryPoint = "SendConnectionInfoRequest075")]
    public static void SendConnectionInfoRequest075(int handle, byte @serverId)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            connection.CreateAndSend(pipeWriter =>
            {
                var length = ConnectionInfoRequest075Ref.Length;
                var packet = new ConnectionInfoRequest075Ref(pipeWriter.GetSpan(length)[..length]);
                packet.ServerId = @serverId;

                return length;
            });
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="ConnectionInfoRequest" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <param name="serverId">The server id.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client after the user clicked on an entry of the server list.
    /// Causes reaction on server side: The server will send a ConnectionInfo back to the client.
    /// </remarks>
    [UnmanagedCallersOnly(EntryPoint = "SendConnectionInfoRequest")]
    public static void SendConnectionInfoRequest(int handle, ushort @serverId)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            connection.CreateAndSend(pipeWriter =>
            {
                var length = ConnectionInfoRequestRef.Length;
                var packet = new ConnectionInfoRequestRef(pipeWriter.GetSpan(length)[..length]);
                packet.ServerId = @serverId;

                return length;
            });
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="ConnectionInfo" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <param name="ipAddress">The ip address.</param>
    /// <param name="port">The port.</param>
    /// <remarks>
    /// Is sent by the server when: This packet is sent by the server after the client requested the connection information of a server. This happens after the user clicked on a server.
    /// Causes reaction on client side: The client will try to connect to the server with the specified information.
    /// </remarks>
    [UnmanagedCallersOnly(EntryPoint = "SendConnectionInfo")]
    public static void SendConnectionInfo(int handle, IntPtr @ipAddress, ushort @port)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            connection.CreateAndSend(pipeWriter =>
            {
                var length = ConnectionInfoRef.Length;
                var packet = new ConnectionInfoRef(pipeWriter.GetSpan(length)[..length]);
                packet.IpAddress = Marshal.PtrToStringAuto(@ipAddress);
                packet.Port = @port;

                return length;
            });
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="ServerListRequest" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client after it connected and received the 'Hello' message.
    /// Causes reaction on server side: The server will send a ServerListResponse back to the client.
    /// </remarks>
    [UnmanagedCallersOnly(EntryPoint = "SendServerListRequest")]
    public static void SendServerListRequest(int handle)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            connection.CreateAndSend(pipeWriter =>
            {
                var length = ServerListRequestRef.Length;
                var packet = new ServerListRequestRef(pipeWriter.GetSpan(length)[..length]);
                return length;
            });
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="ServerListRequestOld" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client (below season 1) after it connected and received the 'Hello' message.
    /// Causes reaction on server side: The server will send a ServerListResponseOld back to the client.
    /// </remarks>
    [UnmanagedCallersOnly(EntryPoint = "SendServerListRequestOld")]
    public static void SendServerListRequestOld(int handle)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            connection.CreateAndSend(pipeWriter =>
            {
                var length = ServerListRequestOldRef.Length;
                var packet = new ServerListRequestOldRef(pipeWriter.GetSpan(length)[..length]);
                return length;
            });
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="Hello" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <remarks>
    /// Is sent by the server when: This packet is sent by the server after the client connected to the server.
    /// Causes reaction on client side: A game client will request the server list. The launcher would request the patch state.
    /// </remarks>
    [UnmanagedCallersOnly(EntryPoint = "SendHello")]
    public static void SendHello(int handle)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            connection.CreateAndSend(pipeWriter =>
            {
                var length = HelloRef.Length;
                var packet = new HelloRef(pipeWriter.GetSpan(length)[..length]);
                return length;
            });
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="PatchCheckRequest" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <param name="majorVersion">The major version.</param>
    /// <param name="minorVersion">The minor version.</param>
    /// <param name="patchVersion">The patch version.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client (launcher) to check if the patch version is high enough to be able to connect to the server.
    /// Causes reaction on server side: The connect server will check the version and sends a 'PatchVersionOkay' or a 'ClientNeedsPatch' message.
    /// </remarks>
    [UnmanagedCallersOnly(EntryPoint = "SendPatchCheckRequest")]
    public static void SendPatchCheckRequest(int handle, byte @majorVersion, byte @minorVersion, byte @patchVersion)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            connection.CreateAndSend(pipeWriter =>
            {
                var length = PatchCheckRequestRef.Length;
                var packet = new PatchCheckRequestRef(pipeWriter.GetSpan(length)[..length]);
                packet.MajorVersion = @majorVersion;
                packet.MinorVersion = @minorVersion;
                packet.PatchVersion = @patchVersion;

                return length;
            });
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="PatchVersionOkay" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <remarks>
    /// Is sent by the server when: This packet is sent by the server after the client (launcher) requested the to check the patch version and it was high enough.
    /// Causes reaction on client side: The launcher will activate its start button.
    /// </remarks>
    [UnmanagedCallersOnly(EntryPoint = "SendPatchVersionOkay")]
    public static void SendPatchVersionOkay(int handle)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            connection.CreateAndSend(pipeWriter =>
            {
                var length = PatchVersionOkayRef.Length;
                var packet = new PatchVersionOkayRef(pipeWriter.GetSpan(length)[..length]);
                return length;
            });
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="ClientNeedsPatch" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <param name="patchVersion">The patch version.</param>
    /// <param name="patchAddress">The patch address, usually to a ftp server. The address is usually "encrypted" with the 3-byte XOR key (FC CF AB).</param>
    /// <remarks>
    /// Is sent by the server when: This packet is sent by the server after the client (launcher) requested to check the patch version and it requires an update.
    /// Causes reaction on client side: The launcher will download the required patches and then activate the start button.
    /// </remarks>
    [UnmanagedCallersOnly(EntryPoint = "SendClientNeedsPatch")]
    public static void SendClientNeedsPatch(int handle, byte @patchVersion, IntPtr @patchAddress)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            connection.CreateAndSend(pipeWriter =>
            {
                var length = ClientNeedsPatchRef.Length;
                var packet = new ClientNeedsPatchRef(pipeWriter.GetSpan(length)[..length]);
                packet.PatchVersion = @patchVersion;
                packet.PatchAddress = Marshal.PtrToStringAuto(@patchAddress);

                return length;
            });
        }
        catch
        {
            // Log exception
        }
    }}